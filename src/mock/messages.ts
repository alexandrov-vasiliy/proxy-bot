import { IChatMessage } from '@/lib/types';
// eslint-disable no-template-curly-in-string
export const MOCK_MESSAGES: IChatMessage[] = [
    {
        role: 'user',
        content: 'реализуй паттерн proxy на typescript',
    },
    {
        role: 'assistant',
        content: 'Вот пример реализации паттерна "Прокси" на TypeScript:\n\n```typescript\n// Интерфейс, который должен быть реализован классом и прокси\ninterface Subject {\n  request(): void;\n}\n\n// Реализация реального объекта\nclass RealSubject implements Subject {\n  public request(): void {\n    console.log("Реальный объект выполняет запрос.");\n  }\n}\n\n// Реализация прокси\nclass Proxy implements Subject {\n  private realSubject: RealSubject;\n\n  constructor(realSubject: RealSubject) {\n    this.realSubject = realSubject;\n  }\n\n  public request(): void {\n    if (this.checkAccess()) {\n      this.realSubject.request();\n      this.logRequest();\n    }\n  }\n\n  private checkAccess(): boolean {\n    // Проверка доступа\n    console.log("Проверка доступа...");\n    return true;\n  }\n\n  private logRequest(): void {\n    console.log("Запрос залогирован.");\n  }\n}\n\n// Пример использования\nconst realSubject = new RealSubject();\nconst proxy = new Proxy(realSubject);\n\nproxy.request();\n```\n\nВ этом примере у нас есть интерфейс `Subject`, который определяет метод `request()`. Класс `RealSubject` реализует этот интерфейс и выполняет реальную работу. Класс `Proxy` также реализует интерфейс `Subject` и является прокси для объекта `RealSubject`. Он выполняет проверку доступа перед выполнением запроса и логирует запрос после его выполнения.\n\nВ примере мы создаем экземпляр `RealSubject` и передаем его в конструктор `Proxy`. Затем вызываем метод `request()` на прокси, который вызывает метод `request()` на реальном объекте после проверки доступа и логирования запроса.\n\nПолучаем следующий вывод:\n```\nПроверка доступа...\nРеальный объект выполняет запрос.\nЗапрос залогирован.\n```',
    },
    {
        role: 'user',
        content: 'напиши паттерн фабричный метод',
    },
    {
        role: 'assistant',

        content: 'Вот пример реализации паттерна "Ф абричный метод" на TypeScript:\n\n```typescript\n// Абстрактный класс, определяющий интерфейс продукта\nabstract class Product {\n  public abstract operation(): string;\n}\n\n// Конкретный класс продукта A\nclass ConcreteProductA extends Product {\n  public operation(): string {\n    return "Результат работы ConcreteProductA";\n  }\n}\n\n// Конкретный класс продукта B\nclass ConcreteProductB extends Product {\n  public operation(): string {\n    return "Результат работы ConcreteProductB";\n  }\n}\n\n// Абстрактный класс, определяющий интерфейс фабрики\nabstract class Creator {\n  public abstract factoryMethod(): Product;\n\n  public someOperation(): string {\n    const product = this.factoryMethod();\n    return `Создан ${product.operation()}`;\n  }\n}\n\n// Конкретная фабрика A\nclass ConcreteCreatorA extends Creator {\n  public factoryMethod(): Product {\n    return new ConcreteProductA();\n  }\n}\n\n// Конкретная фабрика B\nclass ConcreteCreatorB extends Creator {\n  public factoryMethod(): Product {\n    return new ConcreteProductB();\n  }\n}\n\n// Пример использования\nconst creatorA = new ConcreteCreatorA();\nconsole.log(creatorA.someOperation());\n\nconst creatorB = new ConcreteCreatorB();\nconsole.log(creatorB.someOperation());\n```\n\nВ этом примере у нас есть абстрактный класс `Product`, который определяет интерфейс для продукта. Конкретные классы `ConcreteProductA` и `ConcreteProductB` реализуют этот интерфейс и предоставляют свою собственную реализацию метода `operation()`.\n\nАбстрактный класс `Creator` определяет интерфейс для фабрики, включая метод `factoryMethod()`, который должна реализовать каждая конкретная фабрика. Класс `Creator` также содержит общий метод `someOperation()`, который использует фабричный метод для создания продукта и выполняет с ним некоторую работу.\n\nКонкретные фабрики `ConcreteCreatorA` и `ConcreteCreatorB` наследуют класс `Creator` и реализуют метод `factoryMethod()` для создания конкретных продуктов `ConcreteProductA` и `ConcreteProductB` соответственно.\n\nВ примере мы создаем экземпляры конкретных фабрик `ConcreteCreatorA` и `ConcreteCreatorB` и вызываем их метод `someOperation()`. Каждая фабрика создает свой собственный продукт и выполняет с ним работу.\n\nПолучаем следующий вывод:\n```\nСоздан Результат работы ConcreteProductA\nСоздан Результат работы ConcreteProductB\n```',
    },
    {
        role: 'user',
        content: 'в каких случаях можно использовать паттерн фабрика напиши пример из реального кеса',
    },
    {
        role: 'assistant',
        content: 'Паттерн "Фабрика" применяется в случаях, когда у нас есть некоторое общее поведение или интерфейс, но мы хотим, чтобы конкретная реализация была определена во время выполнения программы.\n\nВот пример из реального случая, когда паттерн "Фабрика" может быть полезен:\n\nПредставьте, что у вас есть приложение для обработки изображений, и вам необходимо обработать различные типы изображений (например, JPEG, PNG, GIF). Каждый тип изображения требует специфической обработки, и вы хотите, чтобы обработка была абстрагирована через общий интерфейс.\n\nВы можете использовать паттерн "Фабрика" для создания фабрики, которая будет создавать экземпляры классов обработки для каждого типа изображения. Каждый класс обработки будет реализовывать общий интерфейс с методом `process()`, но каждый класс будет иметь свою собственную специфическую логику обработки для соответствующего типа изображения.\n\nПример реализации:\n\n```typescript\n// Интерфейс для обработки изображения\ninterface ImageProcessor {\n  process(image: Image): void;\n}\n\n// Класс для представления изображения\nclass Image {\n  private type: string;\n\n  constructor(type: string) {\n    this.type = type;\n  }\n\n  public getType(): string {\n    return this.type;\n  }\n}\n\n// Класс для обработки JPEG изображений\nclass JpegProcessor implements ImageProcessor {\n  public process(image: Image): void {\n    console.log(`Обработка JPEG изображения: ${image.getType()}`);\n    // Логика обработки JPEG изображения\n  }\n}\n\n// Класс для обработки PNG изображений\nclass PngProcessor implements ImageProcessor {\n  public process(image: Image): void {\n    console.log(`Обработка PNG изображения: ${image.getType()}`);\n    // Логика обработки PNG изображения\n  }\n}\n\n// Класс для обработки GIF изображений\nclass GifProcessor implements ImageProcessor {\n  public process(image: Image): void {\n    console.log(`Обработка GIF изображения: ${image.getType()}`);\n    // Логика обработки GIF изображения\n  }\n}\n\n// Фабрика для создания обработчиков изображений\nclass ImageProcessorFactory {\n  public static createImageProcessor(image: Image): ImageProcessor {\n    switch (image.getType()) {\n      case "jpeg":\n        return new JpegProcessor();\n      case "png":\n        return new PngProcessor();\n      case "gif":\n        return new GifProcessor();\n      default:\n        throw new Error(`Неизвестный тип изображения: ${image.getType()}`);\n    }\n  }\n}\n\n// Пример использования\nconst image1 = new Image("jpeg");\nconst processor1 = ImageProcessorFactory.createImageProcessor(image1);\nprocessor1.process(image1);\n\nconst image2 = new Image("png");\nconst processor2 = ImageProcessorFactory.createImageProcessor(image2);\nprocessor2.process(image2);\n\nconst image3 = new Image("gif");\nconst processor3 = ImageProcessorFactory.createImageProcessor(image3);\nprocessor3.process(image3);\n```\n\nВ этом примере у нас есть интерфейс `ImageProcessor`, который определяет метод `process()`. Классы `JpegProcessor`, `PngProcessor` и `GifProcessor` реализуют этот интерфейс и предоставляют свою собственную реализацию для обработки соответствующего типа изображения.\n\nКласс `Image` представляет изображение и имеет метод `getType()`, который возвращает тип изображения.\n\nКласс `ImageProcessorFactory` является фабрикой, которая создает экземпляры классов обработки изображений в зависимости от типа изображения. В зависимости от типа изображения, фабрика создает соответствующий обработчик и возвращает его.\n\nВ примере мы создаем экземпляры класса `Image`, затем используем фабрику для создания соответствующего обработчика изображения и вызываем метод `process()`, чтобы обработать изображение.\n\nПолучаем следующий вывод:\n```\nОбработка JPEG изображения: jpeg\nОбработка PNG изображения: png\nОбработка GIF изображения: gif\n```\n\nТаким образом, паттерн "Фабрика" позволяет нам абстрагировать создание конкретных объектов обработки изображений и предоставляет гибкость в добавлении новых типов обработки в будущем без изменения существующего кода.',
    },
    {
        role: 'user',
        content: 'а паттерн фабричный метод?',
    },
    {
        role: 'assistant',
        content: 'Конечно! Вот пример реализации паттерна "Фабричный метод" на TypeScript:\n\n```typescript\n// Абстрактный класс, определяющий интерфейс продукта\nabstract class Product {\n  public abstract operation(): string;\n}\n\n// Конкретный класс продукта A\nclass ConcreteProductA extends Product {\n  public operation(): string {\n    return "Результат работы ConcreteProductA";\n  }\n}\n\n// Конкретный класс продукта B\nclass ConcreteProductB extends Product {\n  public operation(): string {\n    return "Результат работы ConcreteProductB";\n  }\n}\n\n// Абстрактный класс Creator, определяющий фабричный метод\nabstract class Creator {\n  public abstract factoryMethod(): Product;\n\n  public someOperation(): string {\n    const product = this.factoryMethod();\n    return `Создан ${product.operation()}`;\n  }\n}\n\n// Конкретный класс CreatorA, реализующий фабричный метод для создания продукта A\nclass ConcreteCreatorA extends Creator {\n  public factoryMethod(): Product {\n    return new ConcreteProductA();\n  }\n}\n\n// Конкретный класс CreatorB, реализующий фабричный метод для создания продукта B\nclass ConcreteCreatorB extends Creator {\n  public factoryMethod(): Product {\n    return new ConcreteProductB();\n  }\n}\n\n// Пример использования\nconst creatorA: Creator = new ConcreteCreatorA();\nconsole.log(creatorA.someOperation());\n\nconst creatorB: Creator = new ConcreteCreatorB();\nconsole.log(creatorB.someOperation());\n```\n\nВ этом примере у нас есть абстрактный класс `Product`, который определяет интерфейс для продукта. Конкретные классы `ConcreteProductA` и `ConcreteProductB` реализуют этот интерфейс и предоставляют свою собственную реализацию метода `operation()`.\n\nАбстрактный класс `Creator` определяет абстрактный фабричный метод `factoryMethod()`, который должен быть реализован каждым конкретным создателем. Класс `Creator` также содержит общий метод `someOperation()`, который использует фабричный метод для создания продукта и выполняет с ним некоторую работу.\n\nКонкретные классы создателей `ConcreteCreatorA` и `ConcreteCreatorB` наследуют класс `Creator` и реализуют фабричный метод `factoryMethod()` для создания конкретных продуктов `ConcreteProductA` и `ConcreteProductB` соответственно.\n\nВ примере мы создаем экземпляры конкретных создателей `ConcreteCreatorA` и `ConcreteCreatorB` и вызываем их метод `someOperation()`. Каждый создатель создает свой собственный продукт и выполняет с ним работу.\n\nПолучаем следующий вывод:\n```\nСоздан Результат работы ConcreteProductA\nСоздан Результат работы ConcreteProductB\n```\n\nТаким образом, паттерн "Фабричный метод" позволяет делегировать создание объектов конкретным классам-создателям, которые могут определить свою собственную логику создания продукта, соблюдая общий интерфейс создателя. Это позволяет упростить расширение системы и обеспечить гибкость в создании различных видов продуктов.',
    },
    {
        role: 'user',
        content: 'паттерны в функциональном программировании',
    },
    {
        role: 'assistant',
        content: 'В функциональном программировании существует несколько распространенных паттернов, которые помогают в организации кода и решении различных задач. Ниже приведены некоторые из них:\n\n1. Функциональные паттерны:\n   - Функции высшего порядка: использование функций в качестве аргументов или возвращаемых значений других функций.\n   - Каррирование: преобразование функции с несколькими аргументами в последовательность функций с одним аргументом.\n   - Частичное применение: создание новой функции путем фиксации некоторых аргументов существующей функции.\n   - Рекурсия: вызов функции из нее самой для решения задачи.\n   - Композиция функций: объединение нескольких функций в одну, где вывод одной функции становится входными данными для следующей.\n   - Функциональное программирование без состояния: отсутствие изменяемых переменных, где каждая функция возвращает новое значение, а не изменяет существующее состояние.\n\n2. Структурные паттерны:\n   - Контейнеры: использование контейнерных типов данных, таких как списки, множества или словари, для хранения и обработки данных.\n   - Функции свертки: применение функции к элементам коллекции и последовательное объединение результатов.\n   - Функции отображения: применение функции ко всем элементам коллекции и создание новой коллекции с результатами.\n   - Функции фильтрации: применение предикатной функции к элементам коллекции и создание новой коллекции с элементами, для которых предикат вернул true.\n   - Функции сопоставления с образцом: сопоставление значений с заданными образцами и выполнение соответствующих действий.\n\n3. Паттерны архитектуры:\n   - Модель-представление-контроллер (MVC): разделение программы на три основных компонента для управления данными, их представлением и взаимодействием с пользователем.\n   - Функциональная композиция: построение программы как композиции функций, где каждая функция выполняет конкретную задачу и возвращает результат, который становится входными данными для следующей функции.\n   - Наблюдатель: определение зависимости между объектами таким образом, чтобы изменения в одном объекте автоматически приводили к изменениям в других объектах.\n   - Конвейерные вычисления: разделение вычислений на последовательность шагов, где каждый шаг принимает данные от предыдущего и передает их следующему шагу.\n\nЭто только некоторые из паттернов, используемых в функциональном программировании. Комбинируя их, можно создавать более сложные и эффективные решения для различных задач.',
    },
    {
        role: 'user',
        content: 'преведи примеры структурных паттернов на языке typescript',
    },
];
